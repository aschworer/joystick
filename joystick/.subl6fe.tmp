#!/usr/bin/env python
# -*- coding: utf-8 -*-

###############################################################################
#  
#  JOYSTICK - Real-time plotting and logging while console controlling
#  Copyright (C) 2016  Guillaume Schworer
#  
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#  
#  For any information, bug report, idea, donation, hug, beer, please contact
#    guillaume.schworer@gmail.com
#
###############################################################################

from . import core
tkinter = core.tkinter
FigureCanvasTkAgg = core.mat.backends.backend_tkagg.FigureCanvasTkAgg
np = core.np
from .graph import Graph


__all__ = ['GraphMulti']


class GraphMulti(Graph):
    def __init__(self, name, freq_up=1, pos=(50, 50), size=(400, 400),
                 screen_relative=False, xnpts=30, nlines=2, numbering=True,
                 fmt=["ro-", "gd-"], bgcol='w', axrect=(0.1, 0.1, 0.9, 0.9),
                 grid='k', xylim=(0., None, 0., None), xnptsmax=50,
                 axmargin=(1.1, 1.1), **kwargs):
        """
        Initialises a graph-frame. Use :py:func:`~joystick.graph.Graph.set_xydata` and
        :py:func:`~joystick.graphGraph.get_xydata` to set and get the x- and y-data of the
        graph, or :py:func:`~joystick.graphGraph.set_xylim` and :py:func:`~joystick.graphGraph.get_xylim` to
        get and set the axes limits.

        Args:
          * name (str): the frame name
          * freq_up (float or None): the frequency of update of the frame,
            between 1e-3 and 1e3 Hz, or ``None`` for no update
          * pos (px or %) [optional]: left-top corner position of the
            frame, see ``screen_relative``
          * size (px or %) [optional]: width-height dimension of the
            frame, see ``screen_relative``
          * screen_relative (bool) [optional]: set to ``True`` to give
            ``pos`` and ``size`` as a % of the screen size, or ``False``
            to give then as pixels
          * xnpts (int) [optional]: the number of data points to be plotted
          * nlines (int) [optional]: the number of lines on the frame
          * numbering (bool) [optional]: whether to display the index of
            the lines
          * fmt (str or list of str) [optional]: the format of the line as in
            ``plt.plot(x, y, fmt)``
          * bgcol (color) [optional]: the background color of the graph
          * axrect (list of 4 floats) [optional]: the axes bounds (l,b,w,h)
            as in ``plt.figure.add_axes(rect=(l,b,w,h))``
          * grid (color or None) [optional]: the grid color, or no grid if
            ``None``
          * xylim (list of 4 floats or None) [optional]: the values of the
            axes limits (xmin, xmax, ymin, ymax), where any value can take
            ``None`` to be recalculated according to the data at each update
          * xnptsmax (int) [optional]: the maximum number of data points to
            be recorded, older data points will be deleted
          * axmargin (tuple of 2 floats) [optional]: a expand factor to
            increase the (x, y) axes limits when they are automatically
            calculated from the data (i.e. some xylim is ``None``)

        Kwargs:
          * Any parameter accepted by ``figure.add_axes``
          * Any parameter accepted by ``plt.plot`` (possibly a list of
            `nlines` elements)
          * Will be passed to the optional custom methods
        """
        kwargs['nlines'] = nlines
        kwargs['numbering'] = numbering
        self._rien = None
        super(GraphMulti, self).__init__(name=name, freq_up=freq_up, pos=pos,
                 size=size, screen_relative=screen_relative, xnpts=xnpts,
                 fmt=fmt, bgcol=bgcol, axrect=axrect, grid=grid, xylim=xylim,
                 xnptsmax=xnptsmax, axmargin=axmargin, **kwargs)

    def _init_base(self, **kwargs):
        """
        Separate function from __init__ for re-initialization purpose
        """
        before, after = self._extract_callit('init')
        self._callmthd(before, **kwargs)
        self._numbering = bool(kwargs.pop('numbering'))
        self.nlines = int(kwargs.pop('nlines'))
        self.xnptsmax = int(kwargs.pop('xnptsmax'))
        self.xylim = tuple(kwargs.pop('xylim')[:4])
        self.axmargin = tuple(map(abs, kwargs.pop('axmargin')[:2]))
        self.xnpts = int(kwargs.pop('xnpts'))
        axrect = tuple(kwargs.pop('axrect')[:4])
        self._fig = core.mat.figure.Figure()
        self.ax = self._fig.add_axes(axrect[:2] + (axrect[2]-axrect[0],
                                                   axrect[3]-axrect[1]),
                                     **core.matkwargs(kwargs))
        self._canvas = FigureCanvasTkAgg(self._fig, master=self._window)
        self._canvas.show()
        self._canvas.get_tk_widget().pack(side=tkinter.TOP,
                                          fill=tkinter.BOTH,
                                          expand=True)
        self._canvas._tkcanvas.pack(side=tkinter.TOP,
                                    fill=tkinter.BOTH,
                                    expand=True)
        self.ax.set_axis_bgcolor(kwargs.pop('bgcol'))
        grid = kwargs.pop('grid')
        if grid not in [None, False]:
            self.ax.grid(color=grid, lw=1)
        for ith in range(self.nlines):
            self.ax.plot(0, 0, core.get_ith(kwargs.get('fmt'), ith), **core.matkwargs(kwargs, ith))
            if self.numbering:
                self.ax.text(0, 0, str(ith+1), bbox=dict(color='k', alpha=0.5))
        self._scale_axes()
        self._callmthd(after, **kwargs)
        # core.INITMETHOD left for backward compatibility
        if core.INITMETHOD not in after \
            and core.INITMETHOD not in before \
            and hasattr(self, core.INITMETHOD):
            print("DEPRECATION WARNING: You should add the decorator " \
                  "`@_callit('after', 'init')` on `{}`. Refer to example.py" \
                  " ".format(core.INITMETHOD))
            self._callmthd(core.INITMETHOD, **kwargs)

    def set_xydata(self, x, y, ln=None):
        """
        Sets the x and y data of the graph.
        Give x and y vectors as numpy arrays; only the last
        :py:func:`~joystick.graph.GraphMulti.xnpts` data-points will be displayed
        """
        if self.visible:
            if ln is not None:
                self.ax.lines[ln].set_xdata(x[-self.xnpts:])
                self.ax.lines[ln].set_ydata(y[-self.xnpts:])
                self.ax.texts[ln].set_position((x[-self.xnpts], y[-self.xnpts]))
            else:
                for ith, l in enumerate(self.ax.lines):
                    l.set_xdata(x[ith, -self.xnpts:])
                    l.set_ydata(y[ith, -self.xnpts:])
                    if self.numbering:
                        self.ax.texts[ith].set_position((x[-self.xnpts], y[-self.xnpts]))

    @property
    def numbering(self):
        return self._numbering

    @numbering.setter
    def numbering(self, value):
        if self._numbering == bool(value):
            return
        self._numbering = bool(value)
        if self._numbering:
            for ith, l in enumerate(self.ax.lines):
                self.ax.text(0, 0, str(ith+1), bbox=dict(color='k', alpha=0.5))
        else:
            for ith in range(self.nlines):
                self.ax.texts.pop(0)
    
    def get_xydata(self):
        """
        Returns the x and y data of the graph
        """
        # should be x en 2 dim
        if self.visible:
            return [l.get_xdata() for l in self.ax.lines], [l.get_ydata() for l in self.ax.lines]

    def _get_data_minmax(self):
        x, y = self.get_xydata()
        x = np.concatenate(x)
        y = np.concatenate(y)
        return x.min(), x.max(), y.min(), y.max()
